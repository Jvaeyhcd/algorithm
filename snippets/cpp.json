{
    "初始化t个测试用户的cpp模板": {
        "prefix": "cpp",
        "body": [
            "/**",
            " * @File    :   $TM_FILENAME",
            " * @Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            " * @Author  :   Jvaeyhcd",
            " * @Contact :   huangcd1992@gmail.com",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    fio;",
            "    int t;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template with t test cases."
    },
    "初始化cpp模板": {
        "prefix": "cpp",
        "body": [
            "/**",
            " * @File    :   $TM_FILENAME",
            " * @Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            " * @Author  :   Jvaeyhcd",
            " * @Contact :   huangcd1992@gmail.com",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    fio;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template."
    },
    "INCLUDE": {
        "prefix": "include",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;"
        ],
        "description": "base include"
    },
    "prefix function": {
        "prefix": "sprefix",
        "body": [
            "vector<int> prefix_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> pi(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "String's prefix function."
    },
    "KMP find occurences": {
        "prefix": "kmp",
        "body": [
            "vector<int> find_occurences(string text, string pattern) {",
            "    string cur = pattern + '#' + text;",
            "    int sz1 = text.size(), sz2 = pattern.size();",
            "    vector<int> v;",
            "    vector<int> lps = prefix_function(cur);",
            "    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {",
            "        if (lps[i] == sz2) v.push_back(i - 2 * sz2);",
            "    }",
            "    return v;",
            "}"
        ]
    },
    "Z Algorithm": {
        "prefix": "z_function",
        "body": [
            "vector<int> z_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "        if (i <= r && z[i - l] < r - i + 1) {",
            "            z[i] = z[i - l];",
            "        } else {",
            "            z[i] = max(0, r - i + 1);",
            "            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "        }",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ]
    },
    "string split": {
        "prefix": "s_split",
        "body": [
            "vector<string> split(const string& str, const string& delim) {",
            "    vector<string> res;",
            "    if (\"\" == str) return res;",
            "    char * strs = new char[str.length() + 1];",
            "    strcpy(strs, str.c_str());",
            "",
            "    char * d = new char[delim.length() + 1];",
            "    strcpy(d, delim.c_str());",
            "",
            "    char *p = strtok(strs, d);",
            "    while (p) {",
            "        string s = p;",
            "        res.push_back(s);",
            "        p = strtok(NULL, d);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Split string."
    },
    "quick pow": {
        "prefix": "qpow",
        "body": [
            "template <typename T=long>",
            "T qpow(T a, T n, T mod) {",
            "    if (n == 0) {",
            "        return 1;",
            "    } else if (n % 2 == 1) {",
            "        return qpow(a, n - 1, mod) * a % mod;",
            "    } else {",
            "        T temp = qpow(a, n / 2, mod) % mod;",
            "        return temp * temp % mod;",
            "    }",
            "}"
        ],
        "description": "quick pow"
    },
    "lazy range add segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range add segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] += lazy[node];",
            "            lazy[rson(node)] += lazy[node];",
            "            tree[lson(node)] += lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] += lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_add(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] += val * (r - l + 1);",
            "            lazy[node] += val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_add(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_add(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_add(int l, int r, T val) {",
            "        range_add(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range add segment tree"
    },
    "lazy range set segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range set segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] = lazy[node];",
            "            lazy[rson(node)] = lazy[node];",
            "            tree[lson(node)] = lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] = lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_set(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] = val * (r - l + 1);",
            "            lazy[node] = val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_set(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_set(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_set(int l, int r, T val) {",
            "        range_set(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range set segment tree"
    },
    "range add single query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "class Fenwick {",
            "private:",
            "    vector<T> fenw;",
            "    int n;",
            "public:",
            "    explicit Fenwick(int _n) : n(_n), fenw(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        while (x <= n) {",
            "            fenw[x] += v;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T get(int x) {",
            "        T v{};",
            "        while (x) {",
            "            v += fenw[x];",
            "            x -= lowbit(x);",
            "        }",
            "        return v;",
            "    }",
            "};"
        ],
        "description": "range add single query fenwick"
    },
    "range add range query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "class Fenwick {",
            "private:",
            "    vector<T> fenw, fenw2;",
            "    int n;",
            "public:",
            "    explicit Fenwick(int _n) : n(_n), fenw(_n + 1), fenw2(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        int pos = x;",
            "        while (x <= n) {",
            "            fenw[x] += v;",
            "            fenw2[x] += v * pos;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T get(int x) {",
            "        T v{};",
            "        int pos = x;",
            "        while (x) {",
            "            v += (fenw[x] * (pos + 1) - fenw2[x]);",
            "            x -= lowbit(x);",
            "        }",
            "        return v;",
            "    }",
            "",
            "    T range_query(int l, int r) {",
            "        return get(r) - get(l - 1);",
            "    }",
            "};"
        ],
        "description": "range add range query fenwick"
    },
    "tarjan scc": {
        "prefix": "tarjan",
        "body": [
            "const int MAXN = 1e5 + 1;",
            "",
            "int dfn[MAXN], low[MAXN], tot;",
            "int scc[MAXN], sc;",
            "int sz[MAXN];",
            "",
            "bool vis[MAXN];",
            "vector<int> g[MAXN];",
            "stack<int> st;",
            "",
            "void tarjan(int u) {",
            "    dfn[u] = low[u] = ++tot;",
            "    st.push(u);",
            "    vis[u] = 1;",
            "    for (int i = 0, v; i < g[u].size(); i++) {",
            "        v = g[u][i];",
            "        if (!dfn[v]) {",
            "            tarjan(v);",
            "            low[u] = min(low[u], low[v]);",
            "        } else if (vis[v]) {",
            "            low[u] = min(low[u], dfn[v]);",
            "        }",
            "    }",
            "    if (low[u] == dfn[u]) {",
            "        sc++; int v;",
            "        do {",
            "            v = st.top();",
            "            vis[v] = 0;",
            "            scc[v] = sc;",
            "            sz[sc]++;",
            "            st.pop();",
            "        } while (v != u);",
            "    }",
            "}"
        ]
    }
}