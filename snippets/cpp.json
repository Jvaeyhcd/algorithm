{
    "初始化t个测试用户的cpp模板": {
        "prefix": "cpp",
        "body": [
            "/**",
            " * @File    :   $TM_FILENAME",
            " * @Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            " * @Author  :   Jvaeyhcd",
            " * @Contact :   huangcd1992@gmail.com",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    // freopen(\"input.txt\", \"r\", stdin);",
            "    fio;",
            "    int t;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template with t test cases."
    },
    "初始化cpp模板": {
        "prefix": "cpp",
        "body": [
            "/**",
            " * @File    :   $TM_FILENAME",
            " * @Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            " * @Author  :   Jvaeyhcd",
            " * @Contact :   huangcd1992@gmail.com",
            "**/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    // freopen(\"input.txt\", \"r\", stdin);",
            "    fio;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template."
    },
    "INCLUDE": {
        "prefix": "include",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;"
        ],
        "description": "base include"
    },
    "prefix function": {
        "prefix": "sprefix",
        "body": [
            "vector<int> prefix_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> pi(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "String's prefix function."
    },
    "KMP find occurences": {
        "prefix": "kmp",
        "body": [
            "vector<int> find_occurences(string text, string pattern) {",
            "    string cur = pattern + '#' + text;",
            "    int sz1 = text.size(), sz2 = pattern.size();",
            "    vector<int> v;",
            "    vector<int> lps = prefix_function(cur);",
            "    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {",
            "        if (lps[i] == sz2) v.push_back(i - 2 * sz2);",
            "    }",
            "    return v;",
            "}"
        ]
    },
    "Z Algorithm": {
        "prefix": "z_function",
        "body": [
            "vector<int> z_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "        if (i <= r && z[i - l] < r - i + 1) {",
            "            z[i] = z[i - l];",
            "        } else {",
            "            z[i] = max(0, r - i + 1);",
            "            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "        }",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ]
    },
    "string split": {
        "prefix": "s_split",
        "body": [
            "vector<string> split(const string& str, const string& delim) {",
            "    vector<string> res;",
            "    if (\"\" == str) return res;",
            "    char * strs = new char[str.length() + 1];",
            "    strcpy(strs, str.c_str());",
            "",
            "    char * d = new char[delim.length() + 1];",
            "    strcpy(d, delim.c_str());",
            "",
            "    char *p = strtok(strs, d);",
            "    while (p) {",
            "        string s = p;",
            "        res.push_back(s);",
            "        p = strtok(NULL, d);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Split string."
    },
    "quick pow": {
        "prefix": "qpow",
        "body": [
            "template <typename T=long>",
            "T qpow(T a, T n, T mod) {",
            "    if (n == 0) {",
            "        return 1;",
            "    } else if (n % 2 == 1) {",
            "        return qpow(a, n - 1, mod) * a % mod;",
            "    } else {",
            "        T temp = qpow(a, n / 2, mod) % mod;",
            "        return temp * temp % mod;",
            "    }",
            "}"
        ],
        "description": "quick pow"
    },
    "lazy range add segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range add segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] += lazy[node];",
            "            lazy[rson(node)] += lazy[node];",
            "            tree[lson(node)] += lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] += lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_add(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] += val * (r - l + 1);",
            "            lazy[node] += val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_add(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_add(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_add(int l, int r, T val) {",
            "        range_add(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range add segment tree"
    },
    "lazy range set segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range set segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] = lazy[node];",
            "            lazy[rson(node)] = lazy[node];",
            "            tree[lson(node)] = lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] = lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_set(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] = val * (r - l + 1);",
            "            lazy[node] = val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_set(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_set(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_set(int l, int r, T val) {",
            "        range_set(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range set segment tree"
    },
    "single add range query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "class BIT {",
            "private:",
            "    vector<T> t;",
            "    int n;",
            "public:",
            "    explicit BIT(int _n) : n(_n), t(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, int delta) {",
            "        while (x <= n) {",
            "            t[x] += delta;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    T ask(int x) {",
            "        T ans = 0;",
            "        while (x) {",
            "            ans += t[x];",
            "            x -= lowbit(x);",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    T range_ask(int x, int y) {",
            "        return ask(y) - ask(x - 1);",
            "    }",
            "};"
        ],
        "description": "single add range query fenwick"
    },
    "range add range query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "class BIT {",
            "private:",
            "    vector<T> t1, t2;",
            "    int n;",
            "public:",
            "    explicit BIT(int _n) : n(_n), t1(_n + 1), t2(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            t1[i] += v;",
            "            t2[i] += x * v;",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T ask(int x) {",
            "        T v{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            v += (x + 1) * t1[i] - t2[i];",
            "        }",
            "        return v;",
            "    }",
            "",
            "    T range_ask(int l, int r) {",
            "        return ask(r) - ask(l - 1);",
            "    }",
            "};"
        ],
        "description": "range add range query fenwick"
    },
    "range add single query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "class BIT {",
            "private:",
            "    vector<T> t;",
            "    int n;",
            "public:",
            "    explicit BIT(int _n) : n(_n), t(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        while (x <= n) {",
            "            t[x] += v;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T get(int x) {",
            "        T v{};",
            "",
            "        while (x) {",
            "            v += t[x];",
            "            x -= lowbit(x);",
            "        }",
            "",
            "        return v;",
            "    }",
            "};"
        ],
        "description": "range add single query fenwick"
    },
    "tarjan scc": {
        "prefix": "tarjan",
        "body": [
            "const int MAXN = 1e5 + 1;",
            "",
            "int dfn[MAXN], low[MAXN], tot;",
            "int scc[MAXN], sc;",
            "int sz[MAXN];",
            "",
            "bool vis[MAXN];",
            "vector<int> g[MAXN];",
            "stack<int> st;",
            "",
            "void tarjan(int u) {",
            "    dfn[u] = low[u] = ++tot;",
            "    st.push(u);",
            "    vis[u] = 1;",
            "    for (int i = 0, v; i < g[u].size(); i++) {",
            "        v = g[u][i];",
            "        if (!dfn[v]) {",
            "            tarjan(v);",
            "            low[u] = min(low[u], low[v]);",
            "        } else if (vis[v]) {",
            "            low[u] = min(low[u], dfn[v]);",
            "        }",
            "    }",
            "    if (low[u] == dfn[u]) {",
            "        sc++; int v;",
            "        do {",
            "            v = st.top();",
            "            vis[v] = 0;",
            "            scc[v] = sc;",
            "            sz[sc]++;",
            "            st.pop();",
            "        } while (v != u);",
            "    }",
            "}"
        ]
    },
    "tree's diameter": {
        "prefix": "tree_diameter",
        "body": [
            "const int MAXN = 5e5 + 1;",
            "            ",
            "struct Node",
            "{",
            "    int to, w;",
            "    Node(int _to, int _w) {",
            "        to = _to;",
            "        w = _w;",
            "    }",
            "};",
            "",
            "int n, ans;",
            "vector<Node> g[MAXN];",
            "int d1[MAXN], d2[MAXN];",
            "",
            "void dfs(int u, int pa) {",
            "    d1[u] = d2[u] = 0;",
            "    for (Node p: g[u]) {",
            "        int v = p.to, w = p.w;",
            "        if (v == pa) continue;",
            "        dfs(v, u);",
            "        int t = d1[v] + w;",
            "        if (t > d1[u]) {",
            "            d2[u] = d1[u];",
            "            d1[u] = t;",
            "        } else if (t > d2[u]) {",
            "            d2[u] = t;",
            "        }",
            "    }",
            "    ans = max(ans, d1[u] + d2[u]);",
            "}"
        ],
        "description": "tree's diameter"
    },
    "union find set": {
        "prefix": "dsu",
        "body": [
            "class UnionFindSet {",
            "    vector<int> fa;",
            "    vector<int> rank;",
            "    int n;",
            "",
            "public:",
            "    UnionFindSet(int _n) {",
            "        n = _n;",
            "        fa.resize(n);",
            "        rank.resize(n, 1);",
            "        for (int i = 0; i < n; i++) {",
            "            fa[i] = i;",
            "        }",
            "    }",
            "",
            "    int find(int x) {",
            "        return x == fa[x] ? x : fa[x] = find(fa[x]);",
            "    }",
            "",
            "    bool merge(int x, int y) {",
            "        int fx = find(x), fy = find(y);",
            "        if (fx == fy) {",
            "            return false;",
            "        }",
            "        if (rank[fx] < rank[fy]) {",
            "            swap(fx, fy);",
            "        }",
            "        fa[fy] = fx;",
            "        rank[fx] += rank[fy];",
            "        return true;",
            "    }",
            "};"
        ]
    },
    "trie tree": {
        "prefix": "trie",
        "body": [
            "#define ALPHABET_SIZE 26",
            "#define MIN_ALPHABET 'a'",
            "class TrieNode",
            "{",
            "public:",
            "    bool isEnd;",
            "    char ch;",
            "    int count;",
            "    TrieNode* children[ALPHABET_SIZE];",
            "",
            "    TrieNode(char ch = 0) {",
            "        this->ch = ch;",
            "        isEnd = false;",
            "        count = 1;",
            "        memset(children, 0, sizeof(children));",
            "    }",
            "};",
            "",
            "class Trie",
            "{",
            "private:",
            "    TrieNode* pRoot;",
            "public:",
            "    Trie() {",
            "        pRoot = new TrieNode();",
            "    }",
            "    ~Trie() {",
            "        destory(pRoot);",
            "    }",
            "",
            "    void insert(string str) {",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode->children[ch] != nullptr) {",
            "                curNode = curNode->children[ch];",
            "                curNode->count++;",
            "            } else {",
            "                TrieNode *newNode = new TrieNode(ch);",
            "                curNode->children[ch] = newNode;",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        curNode->isEnd = true;",
            "    }",
            "",
            "    bool search(string str) {",
            "        if (str.length() == 0) {",
            "            return false;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return (curNode != nullptr && curNode->isEnd);",
            "    }",
            "",
            "    bool startWidth(string str) {",
            "        if (str.length() == 0) {",
            "            return false;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return curNode != nullptr;",
            "    }",
            "",
            "    int getPrefixNum(string str) {",
            "        if (str.length() == 0 || !startWidth(str)) {",
            "            return 0;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        if (curNode != nullptr) {",
            "            return curNode->count;",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    TrieNode* getKNode(string str, int k) {",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (k-- == 0) {",
            "                break;",
            "            }",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return curNode;",
            "    }",
            "",
            "    bool remove(string str) {",
            "        if (str.length() == 0 || !search(str)) {",
            "            return false;",
            "        }",
            "",
            "        // only need update node's count",
            "        if (getPrefixNum(str) > 1) {",
            "            int k = str.size();",
            "            TrieNode* lastNode = getKNode(str, k);",
            "            lastNode->isEnd = false;",
            "            while (lastNode != pRoot) {",
            "                lastNode->count--;",
            "                lastNode = getKNode(str, --k);",
            "            }",
            "            return true;",
            "        }",
            "",
            "        bool updateRoot = getPrefixNum(str.substr(0, 1)) == 1;",
            "        TrieNode* curNode = pRoot;",
            "        int k = str.size();",
            "        auto it = str.rbegin();",
            "        while (it != str.rend())",
            "        {",
            "            char ch = *it - MIN_ALPHABET;",
            "            TrieNode* delNode = getKNode(str, k--);",
            "            if (delNode->count == 1 && delNode != pRoot) {",
            "                if (updateRoot) {",
            "                    free(delNode);",
            "                }",
            "                delNode = nullptr;",
            "            } else {",
            "                delNode->count -= 1;",
            "            }",
            "            ++it;",
            "        }",
            "        if (updateRoot) {",
            "            pRoot->children[str[0] - MIN_ALPHABET] = nullptr;",
            "        }",
            "        return true;",
            "    }",
            "",
            "    void destory(TrieNode* pRoot) {",
            "        if (pRoot == nullptr) {",
            "            return;",
            "        }",
            "        for (int i = 0; i < ALPHABET_SIZE; i++) {",
            "            if (pRoot->children[i] != nullptr) {",
            "                destory(pRoot->children[i]);",
            "            }",
            "        }",
            "        delete pRoot;",
            "        pRoot = nullptr;",
            "    }",
            "};"
        ]
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "int inverse(int a, int m) {",
            "    int r = 1;",
            "    while(a > 1) {",
            "        int t = m / a;",
            "        r = (long long)(r) * (m - t) % m;",
            "        a = m - t * a;",
            "    }",
            "    return r;",
            "}",
            "template<int mod>",
            "struct Mint {",
            "    int x;",
            "    Mint(int x = 0) : x(normal(x)) {}",
            "    Mint(long long x) : x(normal(x % mod)) {}",
            "    int normal(int x) {",
            "        if(x >= mod) {",
            "            x -= mod;",
            "        }",
            "        if(x < 0) {",
            "            x += mod;",
            "        }",
            "        return x;",
            "    }",
            "    int val() const {",
            "        return x;",
            "    }",
            "    Mint inv() const {",
            "        assert(x != 0);",
            "        return Mint(inverse(x, mod));",
            "    }",
            "    Mint operator - () const {",
            "        return Mint(mod - x);",
            "    }",
            "    Mint operator += (const Mint &rhs) {",
            "        x = normal(x + rhs.x);",
            "        return *this;",
            "    }",
            "    Mint operator -= (const Mint &rhs) {",
            "        x = normal(x - rhs.x);",
            "        return *this;",
            "    }",
            "    Mint operator *= (const Mint &rhs) {",
            "        x = (long long)(x) * rhs.x % mod;",
            "        return *this;",
            "    }",
            "    Mint operator /= (const Mint &rhs) {",
            "        return *this *= rhs.inv();",
            "    }",
            "    friend Mint operator + (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator - (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator * (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator / (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    friend istream &operator >> (istream &is, Mint &a) {",
            "        long long v;",
            "        is >> v;",
            "        a = Mint(v);",
            "        return is;",
            "    }",
            "    friend ostream &operator << (ostream &os, const Mint &a) {",
            "        os << a.val();",
            "        return os;",
            "    }",
            "};",
            "",
            "using M107 = Mint<1000000007>;",
            "using M998 = Mint<998244353>;"
        ],
        "description": "mint"
    },
    "single add range query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "class BIT2d {",
            "",
            "public:",
            "    explicit BIT2d(int _n, int _m) : n(_n), m(_m), c(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c[i][j] += v;",
            "            }",
            "        }",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += c[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "    T range_ask(int x1, int y1, int x2, int y2) {",
            "        return ask(x2, y2) - ask(x2, y1 - 1) - ask(x1 - 1, y2) + ask(x1 - 1, y1 - 1);",
            "    }",
            "",
            "private:",
            "    int n, m;",
            "    vector<vector<T>> c;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "};"
        ],
        "description": "single add range query 2d BIT"
    },
    "range add single query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "class BIT2d {",
            "",
            "public:",
            "    explicit BIT2d(int _n, int _m) : n(_n), m(_m), c(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c[i][j] += v;",
            "            }",
            "        }",
            "    }",
            "",
            "    void range_add(int x1, int y1, int x2, int y2, int v) {",
            "        add(x1, y1, v);",
            "        add(x2 + 1, y2 + 1, v);",
            "        add(x2 + 1, y1, -v);",
            "        add(x1, y2 + 1, -v);",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += c[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "private:",
            "    int n, m;",
            "    vector<vector<T>> c;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "};"
        ],
        "description": "range add single query 2d BIT"
    },
    "range add range query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "class BIT2d {",
            "",
            "public:",
            "    explicit BIT2d(int _n, int _m) : n(_n), m(_m), c1(_n + 1, vector<T>(_m + 1)), c2(_n + 1, vector<T>(_m + 1)), c3(_n + 1, vector<T>(_m + 1)), c4(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c1[i][j] += v;",
            "                c2[i][j] += x * v;",
            "                c3[i][j] += y * v;",
            "                c4[i][j] += x * y * v;",
            "            }",
            "        }",
            "    }",
            "",
            "    void range_add(int x1, int y1, int x2, int y2, int v) {",
            "        add(x1, y1, v);",
            "        add(x2 + 1, y2 + 1, v);",
            "        add(x2 + 1, y1, -v);",
            "        add(x1, y2 + 1, -v);",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += (x + 1) * (y + 1) * c1[i][j] - (y + 1) * c2[i][j] - (x + 1) * c3[i][j] + c4[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "    T range_ask(int x1, int y1, int x2, int y2) {",
            "        return ask(x2, y2) + ask(x1 - 1, y1 - 1) - ask(x2, y1 - 1) - ask(x1 - 1, y2);",
            "    }",
            "",
            "private:",
            "    int n, m;",
            "    vector<vector<T>> c1, c2, c3, c4;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "};"
        ],
        "description": "range add range query 2d BIT"
    }
}