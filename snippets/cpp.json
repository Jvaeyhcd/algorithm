{
    "初始化t个测试用户的cpp模板": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    // freopen(\"input.txt\", \"r\", stdin);",
            "    // static ofstream g_log(\"output.txt\");",
            "    // cout.rdbuf(g_log.rdbuf());",
            "    fio;",
            "    int t;",
            "    cin >> t;",
            "",
            "    while(t--)",
            "        solve();",
            "",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template with t test cases."
    },
    "初始化cpp模板": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fio ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    // freopen(\"input.txt\", \"r\", stdin);",
            "    // static ofstream g_log(\"output.txt\");",
            "    // cout.rdbuf(g_log.rdbuf());",
            "    fio;",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "A cpp file template."
    },
    "INCLUDE": {
        "prefix": "include",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;"
        ],
        "description": "base include"
    },
    "prefix function": {
        "prefix": "sprefix",
        "body": [
            "vector<int> prefix_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> pi(n);",
            "    for (int i = 1; i < n; i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "        if (s[i] == s[j]) j++;",
            "        pi[i] = j;",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": "String's prefix function."
    },
    "KMP find occurences": {
        "prefix": "kmp",
        "body": [
            "vector<int> find_occurences(string text, string pattern) {",
            "    string cur = pattern + '#' + text;",
            "    int sz1 = text.size(), sz2 = pattern.size();",
            "    vector<int> v;",
            "    vector<int> lps = prefix_function(cur);",
            "    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {",
            "        if (lps[i] == sz2) v.push_back(i - 2 * sz2);",
            "    }",
            "    return v;",
            "}"
        ]
    },
    "Z Algorithm": {
        "prefix": "z_function",
        "body": [
            "vector<int> z_function(string s) {",
            "    int n = (int)s.length();",
            "    vector<int> z(n);",
            "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "        if (i <= r && z[i - l] < r - i + 1) {",
            "            z[i] = z[i - l];",
            "        } else {",
            "            z[i] = max(0, r - i + 1);",
            "            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "        }",
            "        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ]
    },
    "string split": {
        "prefix": "s_split",
        "body": [
            "vector<string> split(const string& str, const string& delim) {",
            "    vector<string> res;",
            "    if (\"\" == str) return res;",
            "    char * strs = new char[str.length() + 1];",
            "    strcpy(strs, str.c_str());",
            "",
            "    char * d = new char[delim.length() + 1];",
            "    strcpy(d, delim.c_str());",
            "",
            "    char *p = strtok(strs, d);",
            "    while (p) {",
            "        string s = p;",
            "        res.push_back(s);",
            "        p = strtok(NULL, d);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Split string."
    },
    "quick pow": {
        "prefix": "qpow",
        "body": [
            "template <typename T=long>",
            "T qpow(T a, T n, T mod) {",
            "    if (n == 0) {",
            "        return 1;",
            "    } else if (n % 2 == 1) {",
            "        return qpow(a, n - 1, mod) * a % mod;",
            "    } else {",
            "        T temp = qpow(a, n / 2, mod) % mod;",
            "        return temp * temp % mod;",
            "    }",
            "}"
        ],
        "description": "quick pow"
    },
    "lazy range add segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range add segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] += lazy[node];",
            "            lazy[rson(node)] += lazy[node];",
            "            tree[lson(node)] += lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] += lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_add(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] += val * (r - l + 1);",
            "            lazy[node] += val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_add(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_add(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(){}",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_add(int l, int r, T val) {",
            "        range_add(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range add segment tree"
    },
    "lazy range set segment tree": {
        "prefix": "segtree",
        "body": [
            "// lazy range set segment tree",
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    vector<T> tree, lazy, arr;",
            "    int n;",
            "",
            "    int lson(int node) { return (node << 1) + 1; }",
            "",
            "    int rson(int node) { return (node << 1) + 2; }",
            "",
            "    void pushup(int node) {",
            "        tree[node] = tree[lson(node)] + tree[rson(node)];",
            "    }",
            "",
            "    void pushdown(int node, int l, int r) {",
            "        if (lazy[node]) {",
            "            int mid = (l + r) >> 1;",
            "            lazy[lson(node)] = lazy[node];",
            "            lazy[rson(node)] = lazy[node];",
            "            tree[lson(node)] = lazy[node] * (mid - l + 1);",
            "            tree[rson(node)] = lazy[node] * (r - mid);",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    void build(int l, int r, int node) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        build(l, mid, lson(node));",
            "        build(mid + 1, r, rson(node));",
            "        pushup(node);",
            "    }",
            "",
            "    void range_set(int L, int R, int l, int r, int node, T val) {",
            "        if (L <= l && r <= R) {",
            "            tree[node] = val * (r - l + 1);",
            "            lazy[node] = val;",
            "            return;",
            "        }",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        if (L <= mid) range_set(L, R, l, mid, lson(node), val);",
            "        if (mid < R) range_set(L, R, mid + 1, r, rson(node), val);",
            "        pushup(node);",
            "    }",
            "",
            "    T range_sum(int L, int R, int l, int r, int node) {",
            "        if (L > r || R < l) return 0;",
            "        else if (L <= l && r <= R) return tree[node];",
            "        pushdown(node, l, r);",
            "        int mid = (l + r) >> 1;",
            "        return range_sum(L, R, l, mid, lson(node)) + range_sum(L, R, mid + 1, r, rson(node));",
            "    }",
            "",
            "public:",
            "    SegmentTree(){}",
            "    SegmentTree(int _n) : n(_n) {",
            "        arr.resize(n, 0);",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    SegmentTree(vector<T> _arr) : arr(_arr) {",
            "        n = arr.size();",
            "        tree.resize(n << 2, 0);",
            "        lazy.resize(n << 2, 0);",
            "        build(0, n - 1, 0);",
            "    }",
            "",
            "    void range_set(int l, int r, T val) {",
            "        range_set(l, r, 0, n - 1, 0, val);",
            "    }",
            "",
            "    T range_sum(int l, int r) {",
            "        return range_sum(l, r, 0, n - 1, 0);",
            "    }",
            "};"
        ],
        "description": "lazy range set segment tree"
    },
    "dynamic segment tree": {
        "prefix": "segtree",
        "body": [
            "const int MAXN = 1e9;",
            "",
            "template<typename T>",
            "struct SegTree {",
            "",
            "    struct SegTreeNode {",
            "        SegTreeNode *left, *right;",
            "        int val, lazy;",
            "        int l, r;",
            "        SegTreeNode() : val(0), lazy(0), left(nullptr), right(nullptr) {}",
            "        SegTreeNode(int _l, int _r) : l(_l), r(_r), val(0), lazy(0), left(nullptr), right(nullptr) {}",
            "    };",
            "",
            "    SegTreeNode *root;",
            "",
            "    SegTree() {",
            "        root = new SegTreeNode(0, MAXN);",
            "    }",
            "",
            "    void modify_add(SegTreeNode *node, int l, int r, int val) {",
            "        int start = node->l, end = node->r;",
            "        if (l <= start && end <= r) {",
            "            node->val += val * (end - start + 1);",
            "            node->lazy += val;",
            "            return;",
            "        }",
            "        pushdown(node);",
            "        int mid = (start + end) >> 1;",
            "        if (l <= mid) modify_add(node->left, l, r, val);",
            "        if (mid < r) modify_add(node->right, l, r, val);",
            "        pushup(node);",
            "    }",
            "",
            "    T query(SegTreeNode *node, int l, int r) {",
            "        int start = node->l, end = node->r;",
            "        if (l > end || r < start) return 0;",
            "        else if (l <= start && end <= r) return node->val;",
            "        pushdown(node);",
            "        return query(node->left, l, r) + query(node->right, l, r);",
            "    }",
            "",
            "    void pushdown(SegTreeNode *node) {",
            "        int l = node->l, r = node->r;",
            "        int mid = (l + r) >> 1;",
            "        if (!node->left) node->left = new SegTreeNode(l, mid);",
            "        if (!node->right) node->right = new SegTreeNode(mid + 1, r);",
            "        if (node->lazy) {",
            "            int ln = mid - l + 1, rn = r - mid;",
            "            node->left->val += node->lazy * ln;",
            "            node->right->val += node->lazy * rn;",
            "            node->left->lazy += node->lazy;",
            "            node->right->lazy += node->lazy;",
            "            node->lazy = 0;",
            "        }",
            "    }",
            "",
            "    void pushup(SegTreeNode * node) {",
            "        node->val = node->left->val + node->right->val;",
            "    }",
            "};"
        ],
        "description": "dynamic segment tree"
    },
    "single add range query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "struct BIT {",
            "    vector<T> t;",
            "    int n;",
            "",
            "    BIT(int _n) : n(_n), t(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, int delta) {",
            "        while (x <= n) {",
            "            t[x] += delta;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    T ask(int x) {",
            "        T ans = 0;",
            "        while (x) {",
            "            ans += t[x];",
            "            x -= lowbit(x);",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    T range_ask(int x, int y) {",
            "        return ask(y) - ask(x - 1);",
            "    }",
            "};"
        ],
        "description": "single add range query fenwick"
    },
    "range add range query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "struct BIT {",
            "    vector<T> t1, t2;",
            "    int n;",
            "",
            "    BIT(int _n) : n(_n), t1(_n + 1), t2(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            t1[i] += v;",
            "            t2[i] += x * v;",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T ask(int x) {",
            "        T v{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            v += (x + 1) * t1[i] - t2[i];",
            "        }",
            "        return v;",
            "    }",
            "",
            "    T range_ask(int l, int r) {",
            "        return ask(r) - ask(l - 1);",
            "    }",
            "};"
        ],
        "description": "range add range query fenwick"
    },
    "range add single query fenwick": {
        "prefix": "fenwick",
        "body": [
            "template<typename T>",
            "struct BIT {",
            "    vector<T> t;",
            "    int n;",
            "",
            "    BIT(int _n) : n(_n), t(_n + 1) {};",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    void add(int x, T v) {",
            "        while (x <= n) {",
            "            t[x] += v;",
            "            x += lowbit(x);",
            "        }",
            "    }",
            "",
            "    void range_add(int l, int r, T v) {",
            "        add(l, v);",
            "        add(r + 1, -v);",
            "    }",
            "",
            "    T get(int x) {",
            "        T v{};",
            "",
            "        while (x) {",
            "            v += t[x];",
            "            x -= lowbit(x);",
            "        }",
            "",
            "        return v;",
            "    }",
            "};"
        ],
        "description": "range add single query fenwick"
    },
    "tarjan scc": {
        "prefix": "tarjan",
        "body": [
            "const int MAXN = 1e5 + 1;",
            "",
            "int dfn[MAXN], low[MAXN], tot;",
            "int scc[MAXN], sc;",
            "int sz[MAXN];",
            "",
            "bool vis[MAXN];",
            "vector<int> g[MAXN];",
            "stack<int> st;",
            "",
            "void tarjan(int u) {",
            "    dfn[u] = low[u] = ++tot;",
            "    st.push(u);",
            "    vis[u] = 1;",
            "    for (int i = 0, v; i < g[u].size(); i++) {",
            "        v = g[u][i];",
            "        if (!dfn[v]) {",
            "            tarjan(v);",
            "            low[u] = min(low[u], low[v]);",
            "        } else if (vis[v]) {",
            "            low[u] = min(low[u], dfn[v]);",
            "        }",
            "    }",
            "    if (low[u] == dfn[u]) {",
            "        sc++; int v;",
            "        do {",
            "            v = st.top();",
            "            vis[v] = 0;",
            "            scc[v] = sc;",
            "            sz[sc]++;",
            "            st.pop();",
            "        } while (v != u);",
            "    }",
            "}"
        ]
    },
    "tree's diameter": {
        "prefix": "tree_diameter",
        "body": [
            "const int MAXN = 5e5 + 1;",
            "            ",
            "struct Node",
            "{",
            "    int to, w;",
            "    Node(int _to, int _w) {",
            "        to = _to;",
            "        w = _w;",
            "    }",
            "};",
            "",
            "int n, ans;",
            "vector<Node> g[MAXN];",
            "int d1[MAXN], d2[MAXN];",
            "",
            "void dfs(int u, int pa) {",
            "    d1[u] = d2[u] = 0;",
            "    for (Node p: g[u]) {",
            "        int v = p.to, w = p.w;",
            "        if (v == pa) continue;",
            "        dfs(v, u);",
            "        int t = d1[v] + w;",
            "        if (t > d1[u]) {",
            "            d2[u] = d1[u];",
            "            d1[u] = t;",
            "        } else if (t > d2[u]) {",
            "            d2[u] = t;",
            "        }",
            "    }",
            "    ans = max(ans, d1[u] + d2[u]);",
            "}"
        ],
        "description": "tree's diameter"
    },
    "union find set": {
        "prefix": "dsu",
        "body": [
            "struct UnionFindSet {",
            "    vector<int> fa;",
            "    vector<int> rank;",
            "    int n;",
            "",
            "    UnionFindSet(int _n) {",
            "        n = _n;",
            "        fa.resize(n);",
            "        rank.resize(n, 1);",
            "        for (int i = 0; i < n; i++) {",
            "            fa[i] = i;",
            "        }",
            "    }",
            "",
            "    int find(int x) {",
            "        return x == fa[x] ? x : fa[x] = find(fa[x]);",
            "    }",
            "",
            "    bool merge(int x, int y) {",
            "        int fx = find(x), fy = find(y);",
            "        if (fx == fy) {",
            "            return false;",
            "        }",
            "        if (rank[fx] < rank[fy]) {",
            "            swap(fx, fy);",
            "        }",
            "        fa[fy] = fx;",
            "        rank[fx] += rank[fy];",
            "        return true;",
            "    }",
            "};"
        ]
    },
    "trie tree": {
        "prefix": "trie",
        "body": [
            "#define ALPHABET_SIZE 26",
            "#define MIN_ALPHABET 'a'",
            "class TrieNode",
            "{",
            "public:",
            "    bool isEnd;",
            "    char ch;",
            "    int count;",
            "    TrieNode* children[ALPHABET_SIZE];",
            "",
            "    TrieNode(char ch = 0) {",
            "        this->ch = ch;",
            "        isEnd = false;",
            "        count = 1;",
            "        memset(children, 0, sizeof(children));",
            "    }",
            "};",
            "",
            "class Trie",
            "{",
            "private:",
            "    TrieNode* pRoot;",
            "public:",
            "    Trie() {",
            "        pRoot = new TrieNode();",
            "    }",
            "    ~Trie() {",
            "        destory(pRoot);",
            "    }",
            "",
            "    void insert(string str) {",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode->children[ch] != nullptr) {",
            "                curNode = curNode->children[ch];",
            "                curNode->count++;",
            "            } else {",
            "                TrieNode *newNode = new TrieNode(ch);",
            "                curNode->children[ch] = newNode;",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        curNode->isEnd = true;",
            "    }",
            "",
            "    bool search(string str) {",
            "        if (str.length() == 0) {",
            "            return false;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return (curNode != nullptr && curNode->isEnd);",
            "    }",
            "",
            "    bool startWidth(string str) {",
            "        if (str.length() == 0) {",
            "            return false;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return curNode != nullptr;",
            "    }",
            "",
            "    int getPrefixNum(string str) {",
            "        if (str.length() == 0 || !startWidth(str)) {",
            "            return 0;",
            "        }",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        if (curNode != nullptr) {",
            "            return curNode->count;",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    TrieNode* getKNode(string str, int k) {",
            "        TrieNode* curNode = pRoot;",
            "        for (char ch: str) {",
            "            ch -= MIN_ALPHABET;",
            "            if (k-- == 0) {",
            "                break;",
            "            }",
            "            if (curNode != nullptr) {",
            "                curNode = curNode->children[ch];",
            "            }",
            "        }",
            "        return curNode;",
            "    }",
            "",
            "    bool remove(string str) {",
            "        if (str.length() == 0 || !search(str)) {",
            "            return false;",
            "        }",
            "",
            "        // only need update node's count",
            "        if (getPrefixNum(str) > 1) {",
            "            int k = str.size();",
            "            TrieNode* lastNode = getKNode(str, k);",
            "            lastNode->isEnd = false;",
            "            while (lastNode != pRoot) {",
            "                lastNode->count--;",
            "                lastNode = getKNode(str, --k);",
            "            }",
            "            return true;",
            "        }",
            "",
            "        bool updateRoot = getPrefixNum(str.substr(0, 1)) == 1;",
            "        TrieNode* curNode = pRoot;",
            "        int k = str.size();",
            "        auto it = str.rbegin();",
            "        while (it != str.rend())",
            "        {",
            "            char ch = *it - MIN_ALPHABET;",
            "            TrieNode* delNode = getKNode(str, k--);",
            "            if (delNode->count == 1 && delNode != pRoot) {",
            "                if (updateRoot) {",
            "                    free(delNode);",
            "                }",
            "                delNode = nullptr;",
            "            } else {",
            "                delNode->count -= 1;",
            "            }",
            "            ++it;",
            "        }",
            "        if (updateRoot) {",
            "            pRoot->children[str[0] - MIN_ALPHABET] = nullptr;",
            "        }",
            "        return true;",
            "    }",
            "",
            "    void destory(TrieNode* pRoot) {",
            "        if (pRoot == nullptr) {",
            "            return;",
            "        }",
            "        for (int i = 0; i < ALPHABET_SIZE; i++) {",
            "            if (pRoot->children[i] != nullptr) {",
            "                destory(pRoot->children[i]);",
            "            }",
            "        }",
            "        delete pRoot;",
            "        pRoot = nullptr;",
            "    }",
            "};"
        ]
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "int inverse(int a, int m) {",
            "    int r = 1;",
            "    while(a > 1) {",
            "        int t = m / a;",
            "        r = (long long)(r) * (m - t) % m;",
            "        a = m - t * a;",
            "    }",
            "    return r;",
            "}",
            "template<int mod>",
            "struct Mint {",
            "    int x;",
            "    Mint(int x = 0) : x(normal(x)) {}",
            "    Mint(long long x) : x(normal(x % mod)) {}",
            "    int normal(int x) {",
            "        if(x >= mod) {",
            "            x -= mod;",
            "        }",
            "        if(x < 0) {",
            "            x += mod;",
            "        }",
            "        return x;",
            "    }",
            "    int val() const {",
            "        return x;",
            "    }",
            "    Mint inv() const {",
            "        assert(x != 0);",
            "        return Mint(inverse(x, mod));",
            "    }",
            "    Mint operator - () const {",
            "        return Mint(mod - x);",
            "    }",
            "    Mint operator += (const Mint &rhs) {",
            "        x = normal(x + rhs.x);",
            "        return *this;",
            "    }",
            "    Mint operator -= (const Mint &rhs) {",
            "        x = normal(x - rhs.x);",
            "        return *this;",
            "    }",
            "    Mint operator *= (const Mint &rhs) {",
            "        x = (long long)(x) * rhs.x % mod;",
            "        return *this;",
            "    }",
            "    Mint operator /= (const Mint &rhs) {",
            "        return *this *= rhs.inv();",
            "    }",
            "    friend Mint operator + (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator - (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator * (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend Mint operator / (const Mint &lhs, const Mint &rhs) {",
            "        Mint res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    friend istream &operator >> (istream &is, Mint &a) {",
            "        long long v;",
            "        is >> v;",
            "        a = Mint(v);",
            "        return is;",
            "    }",
            "    friend ostream &operator << (ostream &os, const Mint &a) {",
            "        os << a.val();",
            "        return os;",
            "    }",
            "};",
            "",
            "using M107 = Mint<1000000007>;",
            "using M998 = Mint<998244353>;"
        ],
        "description": "mint"
    },
    "single add range query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "struct BIT2d {",
            "    int n, m;",
            "    vector<vector<T>> c;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    BIT2d(int _n, int _m) : n(_n), m(_m), c(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c[i][j] += v;",
            "            }",
            "        }",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += c[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "    T range_ask(int x1, int y1, int x2, int y2) {",
            "        return ask(x2, y2) - ask(x2, y1 - 1) - ask(x1 - 1, y2) + ask(x1 - 1, y1 - 1);",
            "    }",
            "",
            "};"
        ],
        "description": "single add range query 2d BIT"
    },
    "range add single query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "struct BIT2d {",
            "    int n, m;",
            "    vector<vector<T>> c;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    BIT2d(int _n, int _m) : n(_n), m(_m), c(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c[i][j] += v;",
            "            }",
            "        }",
            "    }",
            "",
            "    void range_add(int x1, int y1, int x2, int y2, int v) {",
            "        add(x1, y1, v);",
            "        add(x2 + 1, y2 + 1, v);",
            "        add(x2 + 1, y1, -v);",
            "        add(x1, y2 + 1, -v);",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += c[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "};"
        ],
        "description": "range add single query 2d BIT"
    },
    "range add range query 2d BIT": {
        "prefix": "bit2d",
        "body": [
            "template<typename T>",
            "struct BIT2d {",
            "    int n, m;",
            "    vector<vector<T>> c1, c2, c3, c4;",
            "",
            "    int lowbit(int x) {",
            "        return x & (-x);",
            "    }",
            "",
            "    BIT2d(int _n, int _m) : n(_n), m(_m), c1(_n + 1, vector<T>(_m + 1)), c2(_n + 1, vector<T>(_m + 1)), c3(_n + 1, vector<T>(_m + 1)), c4(_n + 1, vector<T>(_m + 1)) {};",
            "",
            "    void add(int x, int y, T v) {",
            "        for (int i = x; i <= n; i += lowbit(i)) {",
            "            for (int j = y; j <= m; j += lowbit(j)) {",
            "                c1[i][j] += v;",
            "                c2[i][j] += x * v;",
            "                c3[i][j] += y * v;",
            "                c4[i][j] += x * y * v;",
            "            }",
            "        }",
            "    }",
            "",
            "    void range_add(int x1, int y1, int x2, int y2, int v) {",
            "        add(x1, y1, v);",
            "        add(x2 + 1, y2 + 1, v);",
            "        add(x2 + 1, y1, -v);",
            "        add(x1, y2 + 1, -v);",
            "    }",
            "",
            "    T ask(int x, int y) {",
            "        T tot{};",
            "        for (int i = x; i; i -= lowbit(i)) {",
            "            for (int j = y; j; j -= lowbit(j)) {",
            "                tot += (x + 1) * (y + 1) * c1[i][j] - (y + 1) * c2[i][j] - (x + 1) * c3[i][j] + c4[i][j];",
            "            }",
            "        }",
            "        return tot;",
            "    }",
            "",
            "    T range_ask(int x1, int y1, int x2, int y2) {",
            "        return ask(x2, y2) + ask(x1 - 1, y1 - 1) - ask(x2, y1 - 1) - ask(x1 - 1, y2);",
            "    }",
            "",
            "};"
        ],
        "description": "range add range query 2d BIT"
    },
    "heavy-light decomposition": {
        "prefix": "hld",
        "body": [
            "struct HLD {",
            "    int n, tot;",
            "    vector<int> sz, dep, fa, son;",
            "    vector<int> top, dfn, rnk;",
            "    vector<vector<int>> adj;",
            "    SegmentTree<long long> seg;",
            "",
            "    HLD(){}",
            "    HLD(int _n) : n(_n) {",
            "        init(_n);",
            "    }",
            "    ",
            "    void init(int _n) {",
            "        n = _n;",
            "        tot = 0;",
            "        sz.resize(n, 0);",
            "        dep.resize(n, 0);",
            "        fa.resize(n, 0);",
            "        son.resize(n, 0);",
            "        top.resize(n, 0);",
            "        dfn.resize(n, 0);",
            "        rnk.resize(n, 0);",
            "        adj.assign(n, {});",
            "        seg = SegmentTree<long long>(n);",
            "    }",
            "",
            "    void work(int root = 1) {",
            "        top[root] = root;",
            "        dep[root] = 0;",
            "        dfs1(root, 0);",
            "        dfs2(root, root);",
            "    }",
            "    ",
            "    void addEdge(int u, int v) {",
            "        adj[u].push_back(v);",
            "        adj[v].push_back(u);",
            "    }",
            "",
            "    void dfs1(int u, int f) {",
            "        dep[u] = dep[f] + 1;",
            "        sz[u] = 1;",
            "        fa[u] = f;",
            "        for (int v: adj[u]) {",
            "            if (v == f) {",
            "                continue;",
            "            }",
            "            dfs1(v, u);",
            "            sz[u] += sz[v];",
            "            if (!son[u] || sz[v] > sz[son[u]]) {",
            "                son[u] = v;",
            "            }",
            "        }",
            "    }",
            "    ",
            "    void dfs2(int u, int t) {",
            "        top[u] = t;",
            "        tot++;",
            "        dfn[u] = tot;",
            "        rnk[tot] = u;",
            "        if (!son[u]) {",
            "            return;",
            "        }",
            "        dfs2(son[u], t);",
            "        for (int v: adj[u]) {",
            "            if (v != fa[u] && v != son[u]) {",
            "                dfs2(v, v);",
            "            }",
            "        }",
            "    }",
            "    ",
            "    int lca(int x, int y) {",
            "        while (top[x] != top[y]) {",
            "            if (dep[top[x]] < dep[top[y]]) {",
            "                swap(x, y);",
            "            }",
            "            x = fa[top[x]];",
            "        }",
            "        return dep[x] < dep[y] ? x : y;",
            "    }",
            "",
            "    int dist(int u, int v) {",
            "        return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
            "    }",
            "",
            "    void rangeAdd(int u, int v, int delta) {",
            "        while (top[u] != top[v]) {",
            "            if (dep[top[u]] < dep[top[v]]) {",
            "                swap(u, v);",
            "            }",
            "            seg.range_add(dfn[top[u]], dfn[u], delta);",
            "            u = fa[top[u]];",
            "        }",
            "        if (dep[u] < dep[v]) {",
            "            swap(u, v);",
            "        }",
            "        seg.range_add(dfn[v], dfn[u], delta);",
            "    }",
            "",
            "    void subtreeAdd(int u, int delta) {",
            "        seg.range_add(dfn[u], dfn[u] + sz[u] - 1, delta);",
            "    }",
            "",
            "    long long querySubtree(int u) {",
            "        return seg.range_sum(dfn[u], dfn[u] + sz[u] - 1);",
            "    }",
            "",
            "    long long queryPath(int u, int v) {",
            "        long long ans = 0;",
            "        while (top[u] != top[v]) {",
            "            if (dep[top[u]] < dep[top[v]]) {",
            "                swap(u, v);",
            "            }",
            "            ans += seg.range_sum(dfn[top[u]], dfn[u]);",
            "            u = fa[top[u]];",
            "        }",
            "        if (dep[u] < dep[v]) {",
            "            swap(u, v);",
            "        }",
            "        ans += seg.range_sum(dfn[v], dfn[u]);",
            "        return ans;",
            "    }",
            "",
            "    void printAllDatas() {",
            "        for (int i = 1; i <= n; i++) {",
            "            cout << queryPath(i, i) << \" \";",
            "        }",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "heavy-light decomposition"
    },
    "RMQ Sparse table": {
        "prefix": "st",
        "body": [
            "template<typename T>",
            "struct SparseTable {",
            "    using func_type = function<T(const T &, const T &)>;",
            "    static T default_func(const T &t1, const T &t2) {",
            "        return max(t1, t2);",
            "    }",
            "    vector<vector<T>> st;",
            "    func_type op;",
            "",
            "    SparseTable(const vector<T>& a, func_type _func = default_func) {",
            "        op = _func;",
            "        int n = a.size();",
            "        int k = ceil(log2(n)) + 1;",
            "        st.resize(n, vector<T>(k, 0));",
            "        for (int i = 0; i < n; i++) {",
            "            st[i][0] = a[i];",
            "        }",
            "        for (int j = 1; j < k; j++) {",
            "            int pj = (1 << (j - 1));",
            "            for (int i = 0; i + pj < n; i++) {",
            "                st[i][j] = op(st[i][j - 1], st[i + pj][j - 1]);",
            "            }",
            "        }",
            "    }",
            "    T query(int l, int r) {",
            "        int k = log2(r - l + 1);",
            "        return op(st[l][k], st[r - (1 << k) + 1][k]);",
            "    }",
            "};"
        ],
        "description": "RMQ Sparse table"
    },
    "dijkstra": {
        "prefix": "Dijkstra shortest path algorithm",
        "body": [
            "const int MAXN = 100005;",
            "",
            "struct Edge {",
            "    int v, w;",
            "    Edge(int _v, int _w) : v(_v), w(_w) {}",
            "};",
            "",
            "struct Node {",
            "    int u;",
            "    long long dis;",
            "    Node(int _u, long long _dis) : u(_u), dis(_dis) {}",
            "",
            "    bool operator< (const Node& a) const {",
            "        return dis < a.dis;",
            "    }",
            "",
            "    bool operator> (const Node& a) const {",
            "        return dis > a.dis;",
            "    }",
            "};",
            "",
            "long long dis[MAXN];",
            "vector<Edge> g[MAXN];",
            "int vis[MAXN];",
            "priority_queue<Node, vector<Node>, greater<Node>> q;",
            "",
            "void dijkstra(int s) {",
            "    memset(dis, 0x3f, sizeof(dis));",
            "    dis[s] = 0;",
            "    q.push(Node(s, 0));",
            "    while (!q.empty()) {",
            "        int u = q.top().u;",
            "        q.pop();",
            "        if (vis[u]) continue;",
            "        vis[u] = 1;",
            "        for (auto ed: g[u]) {",
            "            int v = ed.v, w = ed.w;",
            "            if (dis[v] > dis[u] + w) {",
            "                dis[v] = dis[u] + w;",
            "                q.push(Node(v, dis[v]));",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra shortest path algorithm"
    }
}