{
    "HEADER": {
        "prefix": "head",
        "body": [
            "#!/usr/bin/env python",
            "# -*- encoding: utf-8 -*-",
            "'''",
            "@File    :   $TM_FILENAME",
            "@Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
            "@Author  :   Jvaeyhcd",
            "@Contact :   huangcd1992@gmail.com",
            "'''",
            "",
            "# here put the import lib",
            "import sys",
            "input = sys.stdin.readline",
            "",
            "############ ---- Input Functions ---- ############",
            "def inp():",
            "    return int(input())",
            "def inlt():",
            "    return list(map(int, input().split()))",
            "def insr():",
            "    s = input()",
            "    return list(s[:len(s) - 1])",
            "def invr():",
            "    return map(int, input().split())",
            "",
            "",
            "def solve():",
            "    $0",
            "",
            "solve()"
        ]
    },
    "标准树状数组": {
        "prefix": "fenwick1",
        "body": [
            "class FenwickTree:",
            "    def __init__(self, n):",
            "        self.bit_arr = [0 for _ in range(n + 1)]",
            "",
            "    def update(self, idx: int, delta: int):",
            "        n = len(self.bit_arr)",
            "        while idx < n:",
            "            self.bit_arr[idx] += delta",
            "            idx += self.lowbit(idx)",
            "",
            "    def query(self, idx: int) -> int:",
            "        ans = 0",
            "        while idx:",
            "            ans += self.bit_arr[idx]",
            "            idx -= self.lowbit(idx)",
            "        return ans",
            "",
            "    def lowbit(self, x: int) -> int:",
            "        return x & -x",
            ""
        ],
        "description": "Create single update and single query Fenwick Tree."
    },
    "区间修改单点查询树状数组": {
        "prefix": "fenwick2",
        "body": [
            "class FenwickTree:",
            "    def __init__(self, n):",
            "        self.arr = [0 for _ in range(n + 1)]",
            "",
            "    def update(self, idx: int, delta: int):",
            "        n = len(self.arr)",
            "        while idx < n:",
            "            self.arr[idx] += delta",
            "            idx += self.lowbit(idx)",
            "",
            "    def range_update(self, l: int, r: int, delta: int):",
            "        self.update(l, delta)",
            "        self.update(r + 1, -delta)",
            "",
            "    def query(self, idx: int) -> int:",
            "        ans = 0",
            "        while idx:",
            "            ans += self.arr[idx]",
            "            idx -= self.lowbit(idx)",
            "        return ans",
            "",
            "    def lowbit(self, x: int) -> int:",
            "        return x & -x",
            ""
        ],
        "description": "Create range update and single query Fenwick Tree."
    },
    "区间修改区间查询树状数组-树状数组实现的线段树": {
        "prefix": "fenwick3",
        "body": [
            "class FenwickTree:",
            "    def __init__(self, n):",
            "        self.arr = [0 for _ in range(n + 1)]",
            "        self.arr2 = [0 for _ in range(n + 1)]",
            "",
            "    def update(self, idx: int, delta: int):",
            "        n = len(self.arr)",
            "        pos = idx",
            "        while idx < n:",
            "            self.arr[idx] += delta",
            "            self.arr2[idx] += delta * pos",
            "            idx += self.lowbit(idx)",
            "",
            "    def range_update(self, l: int, r: int, delta: int):",
            "        self.update(l, delta)",
            "        self.update(r + 1, -delta)",
            "",
            "    def query(self, idx: int) -> int:",
            "        ans = 0",
            "        pos = idx",
            "        while idx:",
            "            ans += (self.arr[idx] * (pos + 1) - self.arr2[idx])",
            "            idx -= self.lowbit(idx)",
            "        return ans",
            "",
            "    def range_query(self, l: int, r: int) -> int:",
            "        return self.query(r) - self.query(l - 1)",
            "",
            "    def lowbit(self, x: int) -> int:",
            "        return x & -x",
            ""
        ],
        "description": "Create range query and range query Fenwick Tree."
    },
    "并查集": {
        "prefix": "unionfind",
        "body": [
            "class UnionFind:",
            "    def __init__(self, n: int):",
            "        self.parent = [i for i in range(n)]",
            "        self.size = n",
            "",
            "    def find(self, x: int) -> int:",
            "        if self.parent[x] != x:",
            "            self.parent[x] = self.find(self.parent[x])",
            "        return self.parent[x]",
            "",
            "    def union(self, x: int, y: int):",
            "        root_x, root_y = self.find(x), self.find(y)",
            "        if root_x != root_y:",
            "            self.parent[root_x] = root_y",
            "            self.size -= 1",
            "",
            "    def is_connected(self, x: int, y: int) -> bool:",
            "        return self.find(x) == self.find(y)",
            ""
        ],
        "description": "Create range query and range query Fenwick Tree."
    },
    "线段树": {
        "prefix": "segtree",
        "body": [
            "class SegmentTree:",
            "    def __init__(self, arr: List):",
            "        self.arr = arr",
            "        self.n = len(arr)",
            "        self.tree = [0 for _ in range(self.n << 2)]",
            "        self.lazy = [0 for _ in range(self.n << 2)]",
            "        self._build(0, self.n - 1, 0)",
            "",
            "    def _ls(self, node: int) -> int:",
            "        return (node << 1) + 1",
            "",
            "    def _rs(self, node: int) -> int:",
            "        return (node << 1) + 2",
            "",
            "    def _push_up(self, node: int):",
            "        self.tree[node] = self.tree[self._ls(node)] + self.tree[self._rs(node)]",
            "",
            "    def _push_down(self, node: int, l: int, r: int):",
            "        if self.lazy[node]:",
            "            mid = (l + r) >> 1",
            "            self.lazy[self._ls(node)] += self.lazy[node]",
            "            self.lazy[self._rs(node)] += self.lazy[node]",
            "            self.tree[self._ls(node)] += self.lazy[node] * (mid - l + 1)",
            "            self.tree[self._rs(node)] += self.lazy[node] * (r - mid)",
            "            self.lazy[node] = 0",
            "",
            "    def _build(self, l: int, r: int, node: int):",
            "        if l == r:",
            "            self.tree[node] = self.arr[l]",
            "            return",
            "",
            "        mid = (l + r) >> 1",
            "        self._build(l, mid, self._ls(node))",
            "        self._build(mid + 1, r, self._rs(node))",
            "        self._push_up(node)",
            "",
            "    def _update(self, L: int, R: int, l: int, r: int, val: int, node: int):",
            "        if L <= l and r <= R:",
            "            self.tree[node] += val * (r - l + 1)",
            "            self.lazy[node] += val",
            "            return",
            "",
            "        self._push_down(node, l, r)",
            "        mid = (l + r) >> 1",
            "        if L <= mid:",
            "            self._update(L, R, l, mid, val, self._ls(node))",
            "        if mid < R:",
            "            self._update(L, R, mid + 1, r, val, self._rs(node))",
            "        self._push_up(node)",
            "",
            "    def _query(self, L: int, R: int, l: int, r: int, node: int) -> int:",
            "        if L > r or R < l:",
            "            return 0",
            "        elif L <= l and r <= R:",
            "            return self.tree[node]",
            "",
            "        self._push_down(node, l, r)",
            "        mid = (l + r) >> 1",
            "        return self._query(L, R, l, mid, self._ls(node)) + self._query(L, R, mid + 1, r, self._rs(node))",
            "",
            "    def update(self, L: int, R: int, val: int):",
            "        self._update(L, R, 0, self.n - 1, val, 0)",
            "",
            "    def query(self, L: int, R: int) -> int:",
            "        return self._query(L, R, 0, self.n - 1, 0)",
            ""
        ]
    },
    "动态开点线段树": {
        "prefix": "segtree2",
        "body": [
            "class SegTreeNode:",
            "",
            "    def __init__(self, l: int = 0, r: int = 0):",
            "        self.lazy = 0",
            "        self.val = 0",
            "        self.l = l",
            "        self.r = r",
            "        self.left = None",
            "        self.right = None",
            "",
            "MAX = int(1e9+1)",
            "",
            "class SegTree:",
            "",
            "    def __init__(self) -> None:",
            "        self.root = SegTreeNode(0, MAX)",
            "",
            "",
            "    def _push_down(self, root: SegTreeNode):",
            "        l, r = root.l, root.r",
            "        mid = (l + r) >> 1",
            "        if not root.left:",
            "            root.left = SegTreeNode(l, mid)",
            "        if not root.right:",
            "            root.right = SegTreeNode(mid + 1, r)",
            "        if root.lazy:",
            "            ln, rn = mid - l + 1, r - mid",
            "            root.left.lazy += root.lazy",
            "            root.right.lazy += root.lazy",
            "            root.left.val += root.lazy * ln",
            "            root.right.val += root.lazy * rn",
            "            root.lazy = 0",
            "",
            "",
            "    def _push_up(self, root: SegTreeNode):",
            "        root.val = root.left.val + root.right.val",
            "",
            "",
            "    def _update(self, L: int, R: int, val: int, root: SegTreeNode):",
            "        start, end = root.l, root.r",
            "        if L <= start and end <= R:",
            "            root.val += val * (end - start + 1)",
            "            root.lazy += val",
            "            return",
            "",
            "        self._push_down(root)",
            "        mid = (start + end) >> 1",
            "        if L <= mid:",
            "            self._update(L, R, val, root.left)",
            "        if mid < R:",
            "            self._update(L, R, val, root.right)",
            "        self._push_up(root)",
            "",
            "",
            "    def _query(self, L: int, R: int, root: SegTreeNode) -> int:",
            "        start, end = root.l, root.r",
            "        if L > end or R < start:",
            "            return 0",
            "        elif L <= start and end <= R:",
            "            return root.val",
            "",
            "        self._push_down(root)",
            "        return self._query(L, R, root.left) + self._query(L, R, root.right)",
            "",
            "",
            "    def update(self, L: int, R: int, val: int):",
            "        self._update(L, R, val, self.root)",
            "",
            "",
            "    def query(self, L: int, R: int) -> int:",
            "        return self._query(L, R, self.root)"
        ]
    },
    "prefix function": {
        "prefix": "sprefix",
        "body": [
            "def prefix_function(s: str):",
            "    n = len(s)",
            "    pi = [0] * n",
            "    for i in range(1, n):",
            "        j = pi[i - 1]",
            "        while j > 0 and s[i] != s[j]:",
            "            j = pi[j - 1]",
            "        if s[i] == s[j]:",
            "            j += 1",
            "        pi[i] = j",
            "    return pi"
        ],
        "description": "string's prefix function"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "class TrieNode:",
            "    def __init__(self):",
            "        # 是否构成一个完成的单词",
            "        self.is_word = False",
            "        # 子节点",
            "        self.children = {}",
            "",
            "",
            "class Trie:",
            "    def __init__(self):",
            "        self.root = TrieNode()",
            "",
            "    # 加入到树中",
            "    def insert(self, word):",
            "        node = self.root",
            "        for c in word:",
            "            child = node.children.get(c)",
            "            if not child:",
            "                node.children[c] = TrieNode()",
            "            node = node.children[c]",
            "        node.is_word = True",
            "",
            "    # 查找单词",
            "    def search(self, word):",
            "        node = self.root",
            "        for c in word:",
            "            node = node.children.get(c)",
            "            if not node:",
            "                return False",
            "        return node.is_word",
            "",
            "    # 是否是前缀开头",
            "    def start_with(self, prefix):",
            "        node = self.root",
            "        for c in prefix:",
            "            node = node.children.get(c)",
            "            if not node:",
            "                return False",
            "        return True"
        ],
        "description": "Trie"
    },
    "heavy-light decomposition": {
        "prefix": "hld",
        "body": [
            "class HLD:",
            "    ",
            "    def __init__(self, n: int) -> None:",
            "        self.n = n",
            "        self.tot = 0",
            "        self.sz = [0] * n",
            "        self.dep = [0] * n",
            "        self.fa = [0] * n",
            "        self.son = [0] * n",
            "        self.top = [0] * n",
            "        self.dfn = [0] * n",
            "        self.rnk = [0] * n",
            "        self.adj = [[] for _ in range(n)]",
            "",
            "    ",
            "    def work(self, root: int = 1):",
            "        self.top[root] = root",
            "        self.dep[root] = 0",
            "        self.dfs1(root, 0)",
            "        self.dfs2(root, root)",
            "",
            "",
            "    def add(self, u: int, v: int):",
            "        self.adj[u].append(v)",
            "        self.adj[v].append(u)",
            "",
            "    ",
            "    def dfs1(self, u: int, f: int):",
            "        self.dep[u] = self.dep[f] + 1",
            "        self.sz[u] = 1",
            "        self.fa[u] = f",
            "        for v in self.adj[u]:",
            "            if v == f: continue",
            "            self.dfs1(v, u)",
            "            self.sz[u] += self.sz[v]",
            "            if not self.son[u] or self.sz[v] > self.sz[self.son[u]]:",
            "                self.son[u] = v",
            "    ",
            "",
            "    def dfs2(self, u: int, t: int):",
            "        self.top[u] = t",
            "        self.tot += 1",
            "        self.dfn[u] = self.tot",
            "        self.rnk[self.tot] = u",
            "        if not self.son[u]:",
            "            return",
            "        ",
            "        self.dfs2(self.son[u], t)",
            "        for v in self.adj[u]:",
            "            if v != self.fa[u] and v != self.son[u]:",
            "                self.dfs2(v, v)",
            "        ",
            "",
            "    def lca(self, x: int, y: int) -> int:",
            "        while self.top[x] != self.top[y]:",
            "            if self.dep[self.top[x]] < self.dep[self.top[y]]:",
            "                x, y = y, x",
            "            x = self.fa[self.top[x]]",
            "        return x if self.dep[x] < self.dep[y] else y",
            "    ",
            "",
            "    def dist(self, x: int, y: int) -> int:",
            "        return self.dep[x] + self.dep[y] - 2 * self.dep[self.lca(x, y)]"
        ],
        "description": "heavy-light decomposition"
    }
}